"""
â–ˆâ–ˆâ•—â–‘â–‘â–‘â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–‘â–ˆâ–ˆâ•—â–‘â–‘â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–‘â–‘â–‘â–ˆâ–ˆâ•—
â–ˆâ–ˆâ•‘â–‘â–‘â–‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–‘â–‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–‘â–ˆâ–ˆâ•”â•
â–ˆâ–ˆâ•‘â–‘â–‘â–‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ•‘â–‘â–‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–‘
â–ˆâ–ˆâ•‘â–‘â–‘â–‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ•‘â–‘â–‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–‘â–‘â•šâ–ˆâ–ˆâ•”â•â–‘â–‘
â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–‘â–‘â–ˆâ–ˆâ•‘â–‘â–‘â–‘â–ˆâ–ˆâ•‘â–‘â–‘â–‘
â–‘â•šâ•â•â•â•â•â•â–‘â•šâ•â•â•â•â•â•â•â–‘â•šâ•â•â•â•â•â–‘â•šâ•â•â–‘â–‘â•šâ•â•â–‘â–‘â–‘â•šâ•â•â–‘â–‘â–‘
"""

"""
Ãšloha 1: Search and Destroy ğŸ’£

KaÅ¾dÃ¡ stÅ™Ã­leÄka mÃ¡ hernÃ­ mÃ³d Search and Destroy. HrÃ¡Äi jsou rozdÄ›leni do dvou tÃ½mÅ¯, Ãºkolem prvnÃ­ho tÃ½mu je poloÅ¾it bombu.
Bomba od poloÅ¾enÃ­ zaÄne odpoÄÃ­tÃ¡vat Äas do vÃ½buchu, mezitÃ­m druhÃ½ tÃ½m se snaÅ¾Ã­ bombu deaktivovat, neÅ¾ uplyne Äas.
TvÃ½m Ãºkolem je rekurzivnÄ› naprogramovat funkci, kterÃ¡ bude odpoÄÃ­tÃ¡vat Äas do vÃ½buchu.

Je na tobÄ›, jestli budeÅ¡ skuteÄnÄ› Äekat (napÅ™. pomocÃ­ pÅ™Ã­kazu sleep), nebo ÄÃ­sla jen najednou vypÃ­Å¡eÅ¡. 
Pokud ale program bude opravdu Äekat 1 sekundu mezi odpoÄty, bude to vypadat lÃ©pe. (Zeptej se mÄ›, googlu nebo ChatGPT)
"""

def casomira_vybuch(cas):
    # TO-DO: Zde napiÅ¡ svÅ¯j kÃ³d (parametr cas jsou sekundy do vÃ½buchu)
    pass


"""
Ãšloha 2: Random â“

UdÄ›lej funkci, kterÃ¡ vygeneruje nÃ¡hodnÃ© ÄÃ­slo od nuly do sta. Pokud je ÄÃ­slo dÄ›litelnÃ© deseti, zastavÃ­ se, pokud ne, zavolÃ¡ se znovu.
ÄŒÃ­sla vypisuj pomocÃ­ print. VÃ½stupem programu budou tedy nÃ¡hodnÃ¡ ÄÃ­sla o nuly do sta, kterÃ¡ nebudou dÄ›litelnÃ¡ 10.

"""

def generuj():
    # TO-DO: Sem piÅ¡ svÅ¯j kÃ³d
    pass

"""
Ãšloha 3: RekurzivnÃ­ mocnina

Naprogramujte rekurzivnÃ­ funkci, kterÃ¡ vypoÄte mocninu zadanÃ©ho ÄÃ­sla (zÃ¡klad) na zadanou celoÄÃ­selnou mocninu (exponent).

PÅ™Ã­klad:
mocnina(3, 4) = 3 * 3 * 3 * 3 = 81
"""

def mocnina(zaklad, exponent):
    # TO-DO: Sem napiÅ¡ svÅ¯j kÃ³d
    pass
    # return ?

"""
Ãšloha 4: Fibonacciho ÄÃ­sla

UdÄ›lej funkci, kterÃ¡ spoÄÃ­tÃ¡ n-tÃ© Fibonacciho ÄÃ­slo. PrvnÃ­ Fibonacciho ÄÃ­slo je 0, druhÃ© je 1. KaÅ¾dÃ© dalÅ¡Ã­ vznikne tak, Å¾e se seÄtou dvÄ› ÄÃ­sla pÅ™edchozÃ­.
PÅ™Ã­klad:
0 1 1 2 3 5 8 13 21 34 55 ...

Pokud uÅ¾ivatel chce napÅ™. sedmÃ© Fibonacciho ÄÃ­sla, tvÅ¯j program vypÃ­Å¡e: 8
"""


def fibonacciho_cislo(poradi):
    # TO-DO: Sem napiÅ¡ svÅ¯j kÃ³d
    pass
    # return ?


"""
Ãšloha 5*: RekurzivnÃ­ binÃ¡rnÃ­ vyhledÃ¡vÃ¡nÃ­

Naprogramujte rekurzivnÃ­ funkci pro binÃ¡rnÃ­ vyhledÃ¡vÃ¡nÃ­, kterÃ¡ vrÃ¡tÃ­ index hledanÃ©ho prvku v seÅ™azenÃ©m seznamu nebo -1, pokud prvek v seznamu nenÃ­.

PÅ™Ã­klad:
binarni_vyhledavani([1, 3, 5, 7, 9], 5) = 2
binarni_vyhledavani([1, 3, 5, 7, 9], 8) = -1
"""

"""
Ãšloha 6**: Schody

StojÃ­Å¡ dole pod schodiÅ¡tÄ›m, kterÃ© mÃ¡ X schodÅ¯. MÅ¯Å¾eÅ¡ buÄ udÄ›lat normÃ¡lnÃ­ krok nahoru, tj. o jeden schod, nebo jeden schod pÅ™eskoÄit (velkÃ½ krok).
UdÄ›lej funkci, kterÃ¡ spoÄÃ­tÃ¡, kolik je celkem vÅ¡ech moÅ¾nÃ½ch zpÅ¯sobÅ¯, jak se dajÃ­ schody vylÃ©zt (rÅ¯znÃ© sekvence krokÅ¯). 

"""


def schody(pocet_schodu):
    pass